const fs = require('fs-extra');
const {
  userData,
  loadUserData,
  saveUserData,
  getUserInfo,
  isUserReady,
  updateUserActivity,
  getAnswerQueue,
  enqueueAnswer,
  deleteUser,
  makeStorageKey
} = require('./src/core/user-store');
const EncounterAPI = require('./encounter-api');
const { createAnswerService } = require('./src/core/answer-service');
const {
  registerTransport,
  sendMessage: sendPlatformMessage,
  editMessage: editPlatformMessage,
  deleteMessage: deletePlatformMessage,
  sendTyping: sendPlatformTyping,
  answerCallback: answerPlatformCallback
} = require('./src/core/messenger');
const { TelegramAdapter } = require('./src/platforms/telegram/telegram-adapter');
const { VkAdapter } = require('./src/platforms/vk');
const { PlatformEventType, OutboundMessageType } = require('./src/platforms/platform-types');

// –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
require('dotenv').config();

// –¢–æ–∫–µ–Ω Telegram –±–æ—Ç–∞ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è (–æ–±—è–∑–∞—Ç–µ–ª–µ–Ω)
const BOT_TOKEN = process.env.BOT_TOKEN;
const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY;

if (!BOT_TOKEN) {
  console.error('‚ùå –ù–µ –∑–∞–¥–∞–Ω BOT_TOKEN. –î–æ–±–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω –±–æ—Ç–∞ –≤ .env –∏–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è.');
  process.exit(1);
}

if (!ENCRYPTION_KEY) {
  console.error('‚ùå –ù–µ –∑–∞–¥–∞–Ω ENCRYPTION_KEY. –î–æ–±–∞–≤—å—Ç–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∫–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –≤ .env –∏–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è.');
  process.exit(1);
}

// Telegram –∞–¥–∞–ø—Ç–µ—Ä –∏ —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞
const telegramAdapter = new TelegramAdapter({ token: BOT_TOKEN });
let bot = null;
let sendToEncounterAPI = null;
let sendAnswerToEncounter = null;
let processAnswerQueue = null;
let vkAdapterInstance = null;
const TELEGRAM_PLATFORM = telegramAdapter.name;
const VK_GROUP_TOKEN = process.env.VK_GROUP_TOKEN || '';
const VK_GROUP_ID = process.env.VK_GROUP_ID ? Number(process.env.VK_GROUP_ID) : null;
const VK_PLATFORM = 'vk';

const userStates = new Map();

const getStateKey = (platform, userId) => makeStorageKey(platform, userId);
const getUserState = (platform, userId) => userStates.get(getStateKey(platform, userId));
const setUserState = (platform, userId, state) => userStates.set(getStateKey(platform, userId), state);
const clearUserState = (platform, userId) => userStates.delete(getStateKey(platform, userId));

const getPlatformUser = (platform, userId) => getUserInfo(platform, userId);
const isPlatformUserReady = (platform, userId) => isUserReady(platform, userId);
const updatePlatformActivity = (platform, userId, username, firstName) =>
  updateUserActivity(platform, userId, username, firstName);

const sendMessage = (platform, userId, text, options = {}) =>
  sendPlatformMessage(platform, userId, text, options);

const editMessage = (platform, userId, messageId, text, options = {}) =>
  editPlatformMessage(platform, userId, messageId, text, options);

const deleteMessage = (platform, userId, messageId) =>
  deletePlatformMessage(platform, userId, messageId);

const sendTyping = (platform, userId) =>
  sendPlatformTyping(platform, userId);

const answerCallback = (platform, data = {}) =>
  answerPlatformCallback(platform, data);

const editTelegramMessage = (arg1, arg2, arg3, arg4) => {
  if (typeof arg3 === 'undefined' && typeof arg2 === 'object') {
    const options = arg2 || {};
    return editMessage(TELEGRAM_PLATFORM, options.chat_id, options.message_id, arg1, options);
  }
  const options = arg4 || {};
  return editMessage(TELEGRAM_PLATFORM, arg1, arg2, arg3, options);
};

const answerTelegramCallback = (queryId, options = {}) =>
  answerCallback(TELEGRAM_PLATFORM, { queryId, ...options });

function createTelegramContext(msg, overrides = {}) {
  const chatId = String(msg.chat?.id ?? '');
  return {
    platform: TELEGRAM_PLATFORM,
    userId: chatId,
    text: msg.text ?? '',
    from: msg.from
      ? {
          id: msg.from.id,
          username: msg.from.username,
          firstName: msg.from.first_name,
          lastName: msg.from.last_name
        }
      : null,
    meta: {
      chatId: msg.chat?.id,
      messageId: msg.message_id,
      chatType: msg.chat?.type,
      chat: msg.chat,
      raw: msg
    },
    ...overrides
  };
}

function createTelegramCallbackContext(query, overrides = {}) {
  const chatId = query.message?.chat?.id ?? query.from?.id;
  const messageId = query.message?.message_id;
  return {
    platform: TELEGRAM_PLATFORM,
    userId: String(chatId ?? ''),
    text: query.data ?? '',
    payload: query.data,
    meta: {
      chatId,
      messageId,
      queryId: query.id,
      raw: query,
      from: query.from,
      message: query.message
    },
    ...overrides
  };
}

async function handleResetCommand(context) {
  const { platform, userId } = context;
  deleteUser(platform, userId);
  clearUserState(platform, userId);
  await saveUserData();

  await sendMessage(platform, userId,
    'üîÑ –î–∞–Ω–Ω—ã–µ —Å–±—Ä–æ—à–µ–Ω—ã!\n\n' +
    '–í—Å–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —É–¥–∞–ª–µ–Ω—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.'
  );
}

async function handleTestCommand(context) {
  const { platform, userId } = context;
  const user = getPlatformUser(platform, userId);

  if (!isPlatformUserReady(platform, userId)) {
    await sendMessage(platform, userId, '‚ùå –°–Ω–∞—á–∞–ª–∞ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ –±–æ—Ç–∞ –∫–æ–º–∞–Ω–¥–æ–π /start');
    return;
  }

  await sendMessage(platform, userId, 'üîÑ –¢–µ—Å—Ç–∏—Ä—É—é –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');

  try {
    const api = new EncounterAPI(user.domain);
    const isConnected = await api.checkConnection();

    if (!isConnected) {
      await sendMessage(platform, userId, `‚ùå –ù–µ —É–¥–∞–µ—Ç—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –¥–æ–º–µ–Ω—É ${user.domain}`);
      return;
    }

    let authResult = { success: false };

    if (user.authCookies && Object.keys(user.authCookies).length > 0) {
      console.log('üìã –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—É—é –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –¥–ª—è /test');
      authResult = { success: true, cookies: user.authCookies };
    } else {
      console.log('üîê –í—ã–ø–æ–ª–Ω—è–µ–º –Ω–æ–≤—É—é –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –¥–ª—è /test');
      authResult = await api.authenticate(user.login, user.password);
      if (authResult.success) {
        user.authCookies = authResult.cookies;
        await saveUserData();
      }
    }

    if (!authResult.success) {
      await sendMessage(platform, userId, `‚ö†Ô∏è –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –µ—Å—Ç—å, –Ω–æ –æ—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏: ${authResult.message}`);
      return;
    }

    const gameInfo = await api.getGameInfo(user.gameId, user.authCookies, user.login, user.password);

    if (!gameInfo.success) {
      await sendMessage(platform, userId,
        `‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω—ã!\n` +
        `‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏–≥—Ä–µ: ${gameInfo.error}\n\n` +
        `–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–π –æ—Ç–≤–µ—Ç.`
      );
      return;
    }

    const data = gameInfo.data;
    await sendMessage(platform, userId,
      `‚úÖ –¢–µ—Å—Ç —É—Å–ø–µ—à–µ–Ω!\n\n` +
      `üåê –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ: –û–ö\n` +
      `üîê –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è: –û–ö\n` +
      `üéÆ –ò–≥—Ä–∞: ${data.name} (‚Ññ${data.number})\n` +
      `üë§ –ò–≥—Ä–æ–∫: ${data.login}\n` +
      `üë• –ö–æ–º–∞–Ω–¥–∞: ${data.team || '–õ–∏—á–Ω–∞—è –∏–≥—Ä–∞'}\n` +
      `üìä –°—Ç–∞—Ç—É—Å: ${data.status === 'active' ? '–ê–∫—Ç–∏–≤–Ω–∞' : '–ù–µ–∞–∫—Ç–∏–≤–Ω–∞'}\n` +
      (data.level
        ? `üèÜ –£—Ä–æ–≤–µ–Ω—å: ${data.level.name} (‚Ññ${data.level.number})\n` +
          `üìà –°–µ–∫—Ç–æ—Ä–∞: ${data.level.sectorsPassed}/${data.level.sectorsTotal}\n`
        : '') +
      `\n–ì–æ—Ç–æ–≤ –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ –æ—Ç–≤–µ—Ç–æ–≤!`
    );
  } catch (error) {
    await sendMessage(platform, userId, `‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è: ${error.message}`);
  }
}

async function handleAdminCommand(context) {
  const { platform, userId } = context;

  if (platform !== TELEGRAM_PLATFORM) {
    await sendMessage(platform, userId, '‚ùå –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ Telegram');
    return;
  }

  const numericId = Number(userId);
  if (numericId !== ROOT_USER_ID) {
    await sendMessage(platform, userId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏');
    return;
  }

  await showAdminMainMenu(userId);
}

async function handleCancelCommand(context) {
  const { platform, userId } = context;
  const currentState = getUserState(platform, userId);

  if (currentState) {
    clearUserState(platform, userId);
    await sendMessage(platform, userId, '‚ùå –î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ');
  } else {
    await sendMessage(platform, userId, '–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π –¥–ª—è –æ—Ç–º–µ–Ω—ã');
  }
}

async function handleStartCommand(context) {
  const { platform, userId } = context;
  const user = getPlatformUser(platform, userId);

  if (isPlatformUserReady(platform, userId)) {
    setUserState(platform, userId, STATES.READY);
    const message =
      '–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ en_off_bot! üéÆ\n\n' +
      '–í—ã —É–∂–µ –Ω–∞—Å—Ç—Ä–æ–∏–ª–∏ –±–æ—Ç–∞:\n' +
      `üë§ –õ–æ–≥–∏–Ω: ${user.login}\n` +
      `üåê –î–æ–º–µ–Ω: ${user.domain}\n` +
      `üéØ ID –∏–≥—Ä—ã: ${user.gameId}\n\n` +
      '–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –æ—Ç–≤–µ—Ç—ã!';
    const keyboardOptions = createMainKeyboard(platform);
    await sendMessage(platform, userId, message, keyboardOptions);
  } else {
    setUserState(platform, userId, STATES.WAITING_FOR_LOGIN);
    const message =
      '–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ en_off_bot! üéÆ\n\n' +
      '–≠—Ç–æ—Ç –±–æ—Ç –ø–æ–º–æ–∂–µ—Ç –≤–∞–º –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –æ—Ç–≤–µ—Ç—ã –≤ –∏–≥—Ä—É Encounter, –¥–∞–∂–µ –µ—Å–ª–∏ —É –≤–∞—Å –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ—Ç –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞.\n\n' +
      '–î–ª—è –Ω–∞—á–∞–ª–∞ –º–Ω–µ –Ω—É–∂–Ω–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é.\n' +
      '–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –ª–æ–≥–∏–Ω:';
    await sendMessage(platform, userId, message);
  }
}

async function handleCommand(context) {
  const command = (context.commandName || '').toLowerCase();

  switch (command) {
    case 'reset':
      await handleResetCommand(context);
      break;
    case 'test':
      await handleTestCommand(context);
      break;
    case 'admin':
      await handleAdminCommand(context);
      break;
    case 'cancel':
      await handleCancelCommand(context);
      break;
    case 'start':
      await handleStartCommand(context);
      break;
    default:
      break;
  }
}

async function handleCallback(context) {
  const { platform, userId, payload = '', meta = {} } = context;

  if (platform !== TELEGRAM_PLATFORM) {
    return;
  }

  const chatId = meta.chatId ?? userId;
  const messageId = meta.messageId;
  const queryId = meta.queryId;
  const data = typeof payload === 'string' ? payload : '';

  if (!data) {
    if (queryId) {
      await answerCallback(platform, { queryId });
    }
    return;
  }

  if (data.startsWith('admin_') && Number(chatId) !== ROOT_USER_ID) {
    if (queryId) {
      await answerCallback(platform, {
        queryId,
        text: '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞',
        show_alert: true
      });
    }
    return;
  }

  try {
    if (data.startsWith('admin_users_')) {
      const page = parseInt(data.split('_')[2], 10) || 0;
      await showUsersList(chatId, messageId, page);
      if (queryId) await answerCallback(platform, { queryId });
    } else if (data === 'admin_moderation') {
      await showModerationMenu(chatId, messageId);
      if (queryId) await answerCallback(platform, { queryId });
    } else if (data.startsWith('admin_whitelist_')) {
      const page = parseInt(data.split('_')[2], 10) || 0;
      clearUserState(platform, userId);
      await showWhitelistMenu(chatId, messageId, page);
      if (queryId) await answerCallback(platform, { queryId });
    } else if (data === 'admin_back') {
      clearUserState(platform, userId);
      if (messageId) {
        await deleteMessage(platform, chatId, messageId);
      }
      await showAdminMainMenu(chatId);
      if (queryId) await answerCallback(platform, { queryId });
    } else if (data === 'moderation_toggle') {
      adminConfig.moderationEnabled = !adminConfig.moderationEnabled;
      await saveAdminConfig();
      await showModerationMenu(chatId, messageId);
      if (queryId) {
        await answerCallback(platform, {
          queryId,
          text: adminConfig.moderationEnabled ? '‚úÖ –ú–æ–¥–µ—Ä–∞—Ü–∏—è –≤–∫–ª—é—á–µ–Ω–∞' : '‚ùå –ú–æ–¥–µ—Ä–∞—Ü–∏—è –≤—ã–∫–ª—é—á–µ–Ω–∞'
        });
      }
    } else if (data === 'whitelist_add') {
      await handleWhitelistAdd(chatId, messageId);
      if (queryId) await answerCallback(platform, { queryId });
    } else if (data.startsWith('whitelist_remove_')) {
      const index = parseInt(data.split('_')[2], 10);
      await handleWhitelistRemove(chatId, messageId, index, queryId);
      if (queryId) {
        await answerCallback(platform, {
          queryId,
          text: 'üóëÔ∏è –£–¥–∞–ª–µ–Ω–æ –∏–∑ –±–µ–ª–æ–≥–æ —Å–ø–∏—Å–∫–∞'
        });
      }
    } else if (queryId) {
      await answerCallback(platform, { queryId });
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ callback_query:', error);
    if (queryId) {
      await answerCallback(platform, {
        queryId,
        text: '‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥—ã',
        show_alert: true
      });
    }
  }
}

async function handleTextMessage(context) {
  const { platform, userId, text = '', from } = context;
  const messageText = text != null ? String(text) : '';

  updatePlatformActivity(platform, userId, from?.username, from?.firstName);

  if (messageText.startsWith('/')) {
    return;
  }

  const user = getPlatformUser(platform, userId);
  let currentState = getUserState(platform, userId);

  if (!currentState) {
    if (isPlatformUserReady(platform, userId)) {
      currentState = STATES.READY;
      setUserState(platform, userId, STATES.READY);
    } else {
      currentState = STATES.WAITING_FOR_LOGIN;
    }
  }

  if (
    currentState === 'WAITING_FOR_WHITELIST_ENTRY' &&
    platform === TELEGRAM_PLATFORM &&
    Number(userId) === ROOT_USER_ID
  ) {
    await handleWhitelistManualEntry(platform, userId, messageText.trim());
    return;
  }

  await processStateInput(platform, userId, user, currentState, messageText, context);
}

async function handleWhitelistManualEntry(platform, userId, loginInput) {
  if (platform !== TELEGRAM_PLATFORM) {
    return;
  }

  const login = loginInput.trim();

  if (login.length < 2) {
    await sendMessage(platform, userId, '‚ùå –õ–æ–≥–∏–Ω –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞');
    return;
  }

  const exists = adminConfig.whitelist.some(item => {
    const itemLogin = item.login || (item.type === 'encounter' ? item.value : null);
    return itemLogin && itemLogin.toLowerCase() === login.toLowerCase();
  });

  if (exists) {
    await sendMessage(platform, userId, '‚ö†Ô∏è –≠—Ç–æ—Ç –ª–æ–≥–∏–Ω —É–∂–µ –µ—Å—Ç—å –≤ –±–µ–ª–æ–º —Å–ø–∏—Å–∫–µ');
    clearUserState(platform, userId);
    return;
  }

  adminConfig.whitelist.push({
    login,
    addedBy: userId,
    addedAt: Date.now()
  });

  await saveAdminConfig();
  await sendMessage(platform, userId, `‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –±–µ–ª—ã–π —Å–ø–∏—Å–æ–∫:\nüéÆ <code>${login}</code>`, {
    parse_mode: 'HTML'
  });

  clearUserState(platform, userId);
}

async function processStateInput(platform, userId, user, currentState, text, context) {
  switch (currentState) {
    case STATES.WAITING_FOR_LOGIN:
      await handleLoginInput(platform, userId, user, text);
      break;
    case STATES.WAITING_FOR_PASSWORD:
      await handlePasswordInput(platform, userId, user, text);
      break;
    case STATES.WAITING_FOR_GAME_URL:
      await handleGameUrlInput(platform, userId, user, text);
      break;
    case STATES.READY:
      await handleReadyStateInput(platform, userId, user, text, context);
      break;
    default:
      await sendMessage(platform, userId, '‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.');
      setUserState(platform, userId, STATES.WAITING_FOR_LOGIN);
      break;
  }
}

async function handleLoginInput(platform, userId, user, text) {
  user.login = text;
  setUserState(platform, userId, STATES.WAITING_FOR_PASSWORD);
  await sendMessage(platform, userId, `–õ–æ–≥–∏–Ω —Å–æ—Ö—Ä–∞–Ω–µ–Ω: ${text}\n–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å:`);
}

async function handlePasswordInput(platform, userId, user, text) {
  user.password = text;

  if (!user.login || !user.password || user.login.length < 2 || user.password.length < 2) {
    setUserState(platform, userId, STATES.WAITING_FOR_LOGIN);
    await sendMessage(platform, userId, '‚ùå –õ–æ–≥–∏–Ω –∏ –ø–∞—Ä–æ–ª—å –¥–æ–ª–∂–Ω—ã —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞.\n–í–≤–µ–¥–∏—Ç–µ –ª–æ–≥–∏–Ω –µ—â–µ —Ä–∞–∑:');
    return;
  }

  await sendMessage(platform, userId, 'üîÑ –ü—Ä–æ–≤–µ—Ä—è—é –¥–∞–Ω–Ω—ã–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏...');

  try {
    const authResult = await checkAuthentication(user.login, user.password);

    if (authResult.success) {
      user.authCookies = authResult.cookies;
      await saveUserData();
      setUserState(platform, userId, STATES.WAITING_FOR_GAME_URL);
      await sendMessage(platform, userId,
        '‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞!\n–¢–µ–ø–µ—Ä—å –ø—Ä–∏—à–ª–∏—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ –∏–≥—Ä—É Encounter.\n\n' +
        '–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã:\n' +
        '‚Ä¢ https://domain.en.cx/GameDetails.aspx?gid=XXXXX\n' +
        '‚Ä¢ https://domain.en.cx/gameengines/encounter/play/XXXXX/'
      );
    } else {
      setUserState(platform, userId, STATES.WAITING_FOR_LOGIN);
      await sendMessage(platform, userId, `‚ùå ${authResult.message}\n–í–≤–µ–¥–∏—Ç–µ –ª–æ–≥–∏–Ω –µ—â–µ —Ä–∞–∑:`);
    }
  } catch (error) {
    setUserState(platform, userId, STATES.WAITING_FOR_LOGIN);
    await sendMessage(platform, userId, `‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏: ${error.message}\n–í–≤–µ–¥–∏—Ç–µ –ª–æ–≥–∏–Ω –µ—â–µ —Ä–∞–∑:`);
  }
}

async function handleGameUrlInput(platform, userId, user, text) {
  if (!(await checkGameAccess(platform, userId))) {
    return;
  }

  const gameUrlResult = parseGameUrl(text);

  if (!gameUrlResult.success) {
    await sendMessage(platform, userId, `‚ùå ${gameUrlResult.message}\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:`);
    return;
  }

  if (user.domain && user.domain !== gameUrlResult.domain) {
    console.log(`üîÑ –î–æ–º–µ–Ω –∏–∑–º–µ–Ω–∏–ª—Å—è —Å ${user.domain} –Ω–∞ ${gameUrlResult.domain}, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º cookies`);
    user.authCookies = null;
  }

  user.domain = gameUrlResult.domain;
  user.gameId = gameUrlResult.gameId;
  setUserState(platform, userId, STATES.READY);
  await saveUserData();

  const message =
    'üéâ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!\n\n' +
    `üë§ –õ–æ–≥–∏–Ω: ${user.login}\n` +
    `üåê –î–æ–º–µ–Ω: ${user.domain}\n` +
    `üéÆ ID –∏–≥—Ä—ã: ${user.gameId}\n` +
    `üîó –¢–∏–ø —Å—Å—ã–ª–∫–∏: ${gameUrlResult.type}\n\n` +
    '–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –æ—Ç–≤–µ—Ç—ã! –ü—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ –æ—Ç–≤–µ—Ç –≤ —á–∞—Ç.';

  const keyboardOptions = createMainKeyboard(platform);
  await sendMessage(platform, userId, message, keyboardOptions);
}

async function handleReadyStateInput(platform, userId, user, text, context) {
  if (text === '–ó–∞–¥–∞–Ω–∏–µ' || text === '–ó–∞–¥–∞–Ω–∏–µ (—Ñ–æ—Ä–º–∞—Ç)') {
    const formatted = text === '–ó–∞–¥–∞–Ω–∏–µ (—Ñ–æ—Ä–º–∞—Ç)';
    await sendLevelTask(platform, userId, user, formatted);
    return;
  }

  if (text === '–°–µ–∫—Ç–æ—Ä–∞') {
    if (!(await checkGameAccess(platform, userId))) {
      return;
    }

    const waitMsg = await sendMessage(platform, userId, 'üîÑ –ü–æ–ª—É—á–∞—é —Å–ø–∏—Å–æ–∫ —Å–µ–∫—Ç–æ—Ä–æ–≤...');
    try {
      const api = new EncounterAPI(user.domain);

      if (!user.authCookies || Object.keys(user.authCookies).length === 0) {
        const auth = await api.authenticate(user.login, user.password);
        if (!auth.success) {
          throw new Error(auth.message || '–ù–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è');
        }
        user.authCookies = auth.cookies;
        await saveUserData();
      }

      let gameState;
      try {
        gameState = await api.getGameState(user.gameId, user.authCookies);
      } catch (e) {
        const msg = String(e.message || '').toLowerCase();
        if (msg.includes('—Ç—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è') || msg.includes('—Å–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞')) {
          const reauth = await api.authenticate(user.login, user.password);
          if (!reauth.success) {
            throw new Error(reauth.message || '–ù–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è');
          }
          user.authCookies = reauth.cookies;
          await saveUserData();
          gameState = await api.getGameState(user.gameId, user.authCookies);
        } else {
          throw e;
        }
      }

      if (!gameState || !gameState.success) {
        throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã');
      }

      let model = gameState.data;
      if (model.Event !== 0) {
        if (model.Event === 16) {
          gameState = await api.getGameState(user.gameId, user.authCookies);
          if (!gameState.success || gameState.data.Event !== 0) {
            await sendOrUpdateMessage(platform, userId, '‚ö†Ô∏è –ò–≥—Ä–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞ –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ —Å–µ–π—á–∞—Å.', waitMsg?.message_id);
            return;
          }
          model = gameState.data;
        } else {
          await sendOrUpdateMessage(platform, userId, '‚ö†Ô∏è –ò–≥—Ä–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞ –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ —Å–µ–π—á–∞—Å.', waitMsg?.message_id);
          return;
        }
      }

      const level = model.Level;
      if (!level) {
        await sendOrUpdateMessage(platform, userId, '‚ö†Ô∏è –ê–∫—Ç–∏–≤–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –Ω–µ –Ω–∞–π–¥–µ–Ω.', waitMsg?.message_id);
        return;
      }

      const sectors = Array.isArray(level.Sectors) ? level.Sectors : [];
      const totalRequired = Number(level.RequiredSectorsCount) || 0;
      const passedCount = Number(level.PassedSectorsCount) || 0;
      const leftToClose = Math.max(totalRequired - passedCount, 0);

      const sectorsMessage = buildSectorsMessage(platform, {
        sectors,
        totalRequired,
        totalCount: sectors.length,
        passedCount,
        leftToClose
      });

      if (waitMsg?.message_id) {
        if (sectorsMessage.text.length <= 4000) {
          await editMessage(platform, userId, waitMsg.message_id, sectorsMessage.text, sectorsMessage.options);
        } else {
          await editMessage(platform, userId, waitMsg.message_id, sectorsMessage.header, sectorsMessage.options);
          for (const chunk of splitMessageBody(sectorsMessage.body, 4000)) {
            await sendMessage(platform, userId, chunk, sectorsMessage.options);
          }
        }
      } else {
        await sendMessage(platform, userId, sectorsMessage.text, sectorsMessage.options);
      }
    } catch (error) {
      await sendOrUpdateMessage(platform, userId, `‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–µ–∫—Ç–æ—Ä–∞: ${error.message}`, waitMsg?.message_id);
    }
    return;
  }

  if (text === 'üìä –°—Ç–∞—Ç—É—Å –æ—á–µ—Ä–µ–¥–∏') {
    const queueLength = user.answerQueue.length;
    const status = user.isOnline ? 'üü¢ –û–Ω–ª–∞–π–Ω' : 'üî¥ –û—Ñ—Ñ–ª–∞–π–Ω';
    const queueText = queueLength > 0
      ? '–û—á–µ—Ä–µ–¥—å:\n' + user.answerQueue.map((item, index) =>
          `${index + 1}. "${item.answer}" (${new Date(item.timestamp).toLocaleTimeString()})`
        ).join('\n')
      : '–û—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞';

    await sendMessage(platform, userId,
      `–°—Ç–∞—Ç—É—Å: ${status}\n` +
      `–û—Ç–≤–µ—Ç–æ–≤ –≤ –æ—á–µ—Ä–µ–¥–∏: ${queueLength}\n\n` +
      queueText
    );
    return;
  }

  if (text === 'üîó –°–º–µ–Ω–∏—Ç—å –∏–≥—Ä—É') {
    if (!(await checkGameAccess(platform, userId))) {
      return;
    }

    user.authCookies = null;
    await saveUserData();
    setUserState(platform, userId, STATES.WAITING_FOR_GAME_URL);
    await sendMessage(platform, userId,
      '–ü—Ä–∏—à–ª–∏—Ç–µ –Ω–æ–≤—É—é —Å—Å—ã–ª–∫—É –Ω–∞ –∏–≥—Ä—É:\n\n' +
      '‚Ä¢ https://domain.en.cx/GameDetails.aspx?gid=XXXXX\n' +
      '‚Ä¢ https://domain.en.cx/gameengines/encounter/play/XXXXX/'
    );
    return;
  }

  if (text === 'üë§ –°–º–µ–Ω–∏—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é') {
    user.authCookies = null;
    await saveUserData();
    setUserState(platform, userId, STATES.WAITING_FOR_LOGIN);
    await sendMessage(platform, userId, '–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –ª–æ–≥–∏–Ω:');
    return;
  }

  if (!(await checkGameAccess(platform, userId))) {
    return;
  }

  const progressMessage = await sendMessage(platform, userId, `‚è≥ –û—Ç–ø—Ä–∞–≤–ª—è—é –æ—Ç–≤–µ—Ç "${text}"...`);
  const progressMessageId = progressMessage?.message_id ?? progressMessage?.conversation_message_id ?? null;
  const result = await sendAnswerToEncounter(platform, userId, text, progressMessageId);

  if (result && user.answerQueue.length > 0) {
    setTimeout(() => processAnswerQueue(platform, userId), 1200);
  }
}

async function sendLevelTask(platform, userId, user, formatted) {
  if (!(await checkGameAccess(platform, userId))) {
    return;
  }

  const waitText = formatted
    ? 'üîÑ –ü–æ–ª—É—á–∞—é —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–∞–¥–∞–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ —É—Ä–æ–≤–Ω—è...'
    : 'üîÑ –ü–æ–ª—É—á–∞—é –∑–∞–¥–∞–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ —É—Ä–æ–≤–Ω—è...';

  const waitMsg = await sendMessage(platform, userId, waitText);

  try {
    const api = new EncounterAPI(user.domain);

    if (!user.authCookies || Object.keys(user.authCookies).length === 0) {
      const auth = await api.authenticate(user.login, user.password);
      if (!auth.success) {
        throw new Error(auth.message || '–ù–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è');
      }
      user.authCookies = auth.cookies;
      await saveUserData();
    }

    let gameState;
    try {
      gameState = await api.getGameState(user.gameId, user.authCookies);
    } catch (error) {
      const msg = String(error.message || '').toLowerCase();
      if (msg.includes('—Ç—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è') || msg.includes('—Å–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞')) {
        const reauth = await api.authenticate(user.login, user.password);
        if (!reauth.success) {
          throw new Error(reauth.message || '–ù–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è');
        }
        user.authCookies = reauth.cookies;
        await saveUserData();
        gameState = await api.getGameState(user.gameId, user.authCookies);
      } else {
        throw error;
      }
    }

    if (!gameState || !gameState.success) {
      throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã');
    }

    let model = gameState.data;
    if (model.Event !== 0) {
      if (model.Event === 16) {
        gameState = await api.getGameState(user.gameId, user.authCookies);
        if (!gameState.success || gameState.data.Event !== 0) {
          await sendOrUpdateMessage(platform, userId, '‚ö†Ô∏è –ò–≥—Ä–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞ –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ —Å–µ–π—á–∞—Å.', waitMsg?.message_id);
          return;
        }
        model = gameState.data;
      } else {
        await sendOrUpdateMessage(platform, userId, '‚ö†Ô∏è –ò–≥—Ä–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞ –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ —Å–µ–π—á–∞—Å.', waitMsg?.message_id);
        return;
      }
    }

    const level = model.Level;
    if (!level) {
      await sendOrUpdateMessage(platform, userId, '‚ö†Ô∏è –ê–∫—Ç–∏–≤–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –Ω–µ –Ω–∞–π–¥–µ–Ω.', waitMsg?.message_id);
      return;
    }

    const taskFragments = collectTaskFragments(level.Tasks, { formatted });
    const helps = collectHelps(level.Helps, { formatted });
    const timeoutRemain = formatRemain(level.TimeoutSecondsRemain);

    const taskMessage = buildTaskMessage(platform, {
      level,
      taskFragments,
      helps,
      timeoutRemain,
      formatted
    });

    if (waitMsg?.message_id) {
      const editOptions = { ...taskMessage.options };
      if (waitMsg?.conversation_message_id != null) {
        editOptions.conversationMessageId = waitMsg.conversation_message_id;
      }

      if (taskMessage.text.length <= 4000) {
        await editMessage(platform, userId, waitMsg.message_id, taskMessage.text, editOptions);
      } else {
        await editMessage(platform, userId, waitMsg.message_id, taskMessage.header, editOptions);
        for (const chunk of splitMessageBody(taskMessage.body, 4000)) {
          await sendMessage(platform, userId, chunk, taskMessage.options);
        }
      }
    } else {
      await sendMessage(platform, userId, taskMessage.text, taskMessage.options);
    }
  } catch (error) {
    const errorPrefix = formatted
      ? '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–∞–¥–∞–Ω–∏–µ'
      : '‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ';
    await sendOrUpdateMessage(platform, userId, `${errorPrefix}: ${error.message}`, waitMsg?.message_id);
  }
}

// –ê–¥–º–∏–Ω-–∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
let adminConfig = {
  moderationEnabled: false,
  whitelist: []
};

// –ö–µ—à whitelist –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
let whitelistCache = new Set();

// –§–∞–π–ª –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∞–¥–º–∏–Ω–∞
const ADMIN_CONFIG_FILE = 'admin_config.json';

// ID root –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–∞–¥–º–∏–Ω–∞)
const ROOT_USER_ID = 197924096;

// –°–æ—Å—Ç–æ—è–Ω–∏—è –±–æ—Ç–∞
const STATES = {
  WAITING_FOR_LOGIN: 'waiting_for_login',
  WAITING_FOR_PASSWORD: 'waiting_for_password',
  WAITING_FOR_GAME_URL: 'waiting_for_game_url',
  READY: 'ready',
  WAITING_FOR_ANSWER: 'waiting_for_answer'
};

// –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
// –ó–∞–≥—Ä—É–∑–∫–∞ –∞–¥–º–∏–Ω-–∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
async function loadAdminConfig() {
  try {
    if (await fs.pathExists(ADMIN_CONFIG_FILE)) {
      adminConfig = await fs.readJson(ADMIN_CONFIG_FILE);

      // –ú–∏–≥—Ä–∞—Ü–∏—è —Å—Ç–∞—Ä–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ whitelist
      let migrationCount = 0;
      if (adminConfig.whitelist && Array.isArray(adminConfig.whitelist)) {
        adminConfig.whitelist = adminConfig.whitelist.map(item => {
          // –ï—Å–ª–∏ —É–∂–µ –Ω–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç - –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å
          if (item.login) {
            return item;
          }
          // –ï—Å–ª–∏ —Å—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç —Å type === 'encounter'
          if (item.type === 'encounter' && item.value) {
            migrationCount++;
            return {
              login: item.value,
              addedBy: item.addedBy,
              addedAt: item.addedAt
            };
          }
          // –ï—Å–ª–∏ —Å—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç —Å type === 'telegram' - –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
          if (item.type === 'telegram') {
            migrationCount++;
            return null;
          }
          return item;
        }).filter(Boolean); // –£–¥–∞–ª—è–µ–º null –∑–Ω–∞—á–µ–Ω–∏—è

        if (migrationCount > 0) {
          console.log(`–í—ã–ø–æ–ª–Ω–µ–Ω–∞ –º–∏–≥—Ä–∞—Ü–∏—è whitelist: –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ ${migrationCount} –∑–∞–ø–∏—Å–µ–π`);
          await saveAdminConfig();
        }
      }

      rebuildWhitelistCache();
      console.log('–ê–¥–º–∏–Ω-–∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–∞');
    } else {
      // –°–æ–∑–¥–∞–µ–º —Ñ–∞–π–ª —Å –Ω–∞—á–∞–ª—å–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
      await saveAdminConfig();
      console.log('–°–æ–∑–¥–∞–Ω —Ñ–∞–π–ª –∞–¥–º–∏–Ω-–∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏');
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∞–¥–º–∏–Ω-–∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏:', error);
  }
}

// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∞–¥–º–∏–Ω-–∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
async function saveAdminConfig() {
  try {
    await fs.writeJson(ADMIN_CONFIG_FILE, adminConfig, { spaces: 2 });
    rebuildWhitelistCache();
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∞–¥–º–∏–Ω-–∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏:', error);
  }
}

// –ü–µ—Ä–µ—Å–±–æ—Ä–∫–∞ –∫–µ—à–∞ whitelist
function rebuildWhitelistCache() {
  whitelistCache.clear();
  if (adminConfig.whitelist && Array.isArray(adminConfig.whitelist)) {
    adminConfig.whitelist.forEach(entry => {
      // –ù–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç: entry.login –∏–ª–∏ —Å—Ç–∞—Ä—ã–π —Ñ–æ—Ä–º–∞—Ç: entry.type + entry.value
      const login = entry.login || (entry.type === 'encounter' ? entry.value : null);
      if (login) {
        whitelistCache.add(login.toLowerCase());
      }
    });
  }
  console.log(`Whitelist cache –æ–±–Ω–æ–≤–ª–µ–Ω: ${whitelistCache.size} –∑–∞–ø–∏—Å–µ–π`);
}

// –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –¥–ª—è –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é
const MAIN_MENU_LAYOUT = [
  ['–ó–∞–¥–∞–Ω–∏–µ'],
  ['–ó–∞–¥–∞–Ω–∏–µ (—Ñ–æ—Ä–º–∞—Ç)'],
  ['–°–µ–∫—Ç–æ—Ä–∞'],
  ['üìä –°—Ç–∞—Ç—É—Å –æ—á–µ—Ä–µ–¥–∏', 'üîó –°–º–µ–Ω–∏—Ç—å –∏–≥—Ä—É'],
  ['üë§ –°–º–µ–Ω–∏—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é']
];

function createMainKeyboard(platform) {
  if (platform === TELEGRAM_PLATFORM) {
    return {
      reply_markup: {
        keyboard: MAIN_MENU_LAYOUT.map(row => [...row]),
        resize_keyboard: true,
        one_time_keyboard: false
      }
    };
  }

  if (platform === VK_PLATFORM) {
    const buttons = MAIN_MENU_LAYOUT.map(row =>
      row.map(label => ({
        action: {
          type: 'text',
          label,
          payload: JSON.stringify({ type: 'main_menu', value: label })
        },
        color: 'secondary'
      }))
    );

    return {
      keyboard: {
        type: 'reply',
        buttons,
        oneTime: false
      }
    };
  }

  return {};
}

function buildSectorsMessage(platform, { sectors, totalRequired, totalCount, passedCount, leftToClose }) {
  const isTelegram = platform === TELEGRAM_PLATFORM;
  const options = isTelegram
    ? { parse_mode: 'HTML', disable_web_page_preview: true }
    : {};

  if (!Array.isArray(sectors) || sectors.length === 0) {
    const header = isTelegram ? '<b>üóÑ –°–µ–∫—Ç–æ—Ä—ã</b>' : 'üóÑ –°–µ–∫—Ç–æ—Ä—ã';
    const text = `${header}\n\n–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ —Å–µ–∫—Ç–æ—Ä–∞—Ö.`;
    return {
      text,
      header,
      body: '',
      options
    };
  }

  const lines = sectors.map(s => {
    const order = s?.Order ?? '';
    const nameRaw = s?.Name ?? '';
    const name = isTelegram ? escapeHtml(nameRaw) : nameRaw;
    const isAnswered = s?.IsAnswered === true;
    const answerTextRaw = s?.Answer;
    const answerText = extractSectorAnswerText(answerTextRaw);

    if (isTelegram) {
      const safeAnswer = answerText ? `<code>${escapeHtml(answerText)}</code>` : '<code>‚Äî</code>';
      const condition = isAnswered ? `${safeAnswer} ‚úÖ` : '<i>...</i>';
      return `#${order} (${name}) ‚Äî ${condition}`;
    }

    const safeAnswer = answerText ? `¬´${answerText}¬ª` : '‚Äî';
    const condition = isAnswered ? `${safeAnswer} ‚úÖ` : '‚Ä¶';
    return `#${order} (${name}) ‚Äî ${condition}`;
  });

  const header = isTelegram
    ? `<b>üóÑ –°–µ–∫—Ç–æ—Ä—ã (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö ${totalRequired} –∏–∑ ${totalCount})</b>`
    : `üóÑ –°–µ–∫—Ç–æ—Ä—ã (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö ${totalRequired} –∏–∑ ${totalCount})`;

  const summary = isTelegram
    ? `–ó–∞–∫—Ä—ã—Ç–æ ‚Äî <b>${passedCount}</b>, –æ—Å—Ç–∞–ª–æ—Å—å ‚Äî <b>${leftToClose}</b>`
    : `–ó–∞–∫—Ä—ã—Ç–æ ‚Äî ${passedCount}, –æ—Å—Ç–∞–ª–æ—Å—å ‚Äî ${leftToClose}`;

  const body = lines.join('\n');
  const text = `${header}\n\n${summary}\n\n${body}`;

  return {
    text,
    header,
    body,
    options
  };
}

function collectTaskFragments(tasks, { formatted = false } = {}) {
  const fragments = [];
  const field = formatted ? 'TaskTextFormatted' : 'TaskText';

  const addFragment = (rawValue) => {
    if (rawValue == null) {
      return;
    }
    const raw = String(rawValue);
    const presenceCheck = stripHtml(raw).trim();
    if (presenceCheck.length === 0) {
      return;
    }
    fragments.push(formatted ? raw : raw.trim());
  };

  if (Array.isArray(tasks)) {
    for (const task of tasks) {
      const rawValue = task?.[field] ?? task?.TaskText;
      addFragment(rawValue);
    }
  } else if (tasks && typeof tasks === 'object') {
    const rawValue = tasks[field] ?? tasks.TaskText;
    addFragment(rawValue);
  }

  return fragments;
}

function collectHelps(helps, { formatted = false } = {}) {
  const result = [];
  if (!Array.isArray(helps)) {
    return result;
  }

  const field = formatted ? 'HelpTextFormatted' : 'HelpText';

  for (const help of helps) {
    const rawValue = help?.[field] ?? help?.HelpText ?? '';
    const raw = String(rawValue);
    const trimmed = stripHtml(raw).trim();
    const remainSeconds = help?.RemainSeconds ?? null;

    if (trimmed.length === 0 && (remainSeconds == null || remainSeconds <= 0)) {
      // –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç–∞ –Ω–µ—Ç –∏ –ø–æ–¥—Å–∫–∞–∑–∫–∞ –Ω–µ –æ–∂–∏–¥–∞–µ—Ç—Å—è, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
      continue;
    }

    result.push({
      number: help?.Number ?? '',
      text: formatted ? raw : raw.trim(),
      remainSeconds
    });
  }

  return result;
}

function buildTaskMessage(platform, { level, taskFragments, helps, timeoutRemain, formatted = false }) {
  const isTelegram = platform === TELEGRAM_PLATFORM;
  const normalizedHelps = Array.isArray(helps) ? helps : [];
  const options = isTelegram
    ? { parse_mode: 'HTML', disable_web_page_preview: true }
    : {};

  const levelNumber = level?.Number ?? '';
  const levelNameRaw = String(level?.Name || '').trim();
  const levelName = isTelegram ? escapeHtml(levelNameRaw) : levelNameRaw;
  const header = isTelegram
    ? `<b>üìú –ó–∞–¥–∞–Ω–∏–µ —É—Ä–æ–≤–Ω—è ‚Ññ${levelNumber}${levelName ? ` ‚Äî ${levelName}` : ''}</b>`
    : `üìú –ó–∞–¥–∞–Ω–∏–µ —É—Ä–æ–≤–Ω—è ‚Ññ${levelNumber}${levelName ? ` ‚Äî ${levelName}` : ''}`;

  const timeoutLine = timeoutRemain
    ? (isTelegram
      ? `<i>–î–æ –∞–≤—Ç–æ–ø–µ—Ä–µ—Ö–æ–¥–∞ –æ—Å—Ç–∞–ª–æ—Å—å: ${escapeHtml(timeoutRemain)}</i>`
      : `–î–æ –∞–≤—Ç–æ–ø–µ—Ä–µ—Ö–æ–¥–∞ –æ—Å—Ç–∞–ª–æ—Å—å: ${timeoutRemain}`)
    : '';

  const renderTaskFragment = (text) => {
    if (formatted) {
      if (isTelegram) {
        return sanitizeHtmlForTelegram(text);
      }
      return stripHtml(text);
    }
    return isTelegram ? escapeHtml(text) : text;
  };

  let bodyMain;
  if (taskFragments.length > 0) {
    if (!formatted && isTelegram) {
      bodyMain = taskFragments
        .map(fragment => `<blockquote>${renderTaskFragment(fragment)}</blockquote>`)
        .join('\n\n');
    } else {
      const rendered = taskFragments.map(fragment => renderTaskFragment(fragment));
      bodyMain = rendered.join('\n\n');
    }
  } else {
    bodyMain = formatted
      ? (isTelegram ? '<i>–¢–µ–∫—Å—Ç –∑–∞–¥–∞–Ω–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.</i>' : '–¢–µ–∫—Å—Ç –∑–∞–¥–∞–Ω–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.')
      : (isTelegram ? '<blockquote>–¢–µ–∫—Å—Ç –∑–∞–¥–∞–Ω–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.</blockquote>' : '–¢–µ–∫—Å—Ç –∑–∞–¥–∞–Ω–∏—è –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.');
  }

  const helpsSections = [];
  for (const help of normalizedHelps) {
    const number = help.number;
    const label = number ? `üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞ ${number}` : 'üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞';
    const remainStr = formatRemain(help.remainSeconds);
    const helpContent = formatted
      ? (isTelegram ? sanitizeHtmlForTelegram(help.text) : stripHtml(help.text))
      : (isTelegram ? escapeHtml(help.text) : help.text);

    if (isTelegram) {
      if (formatted) {
        const remainLine = remainStr ? `\n<i>–î–æ –ø–æ–¥—Å–∫–∞–∑–∫–∏ –æ—Å—Ç–∞–ª–æ—Å—å: ${escapeHtml(remainStr)}</i>` : '';
        helpsSections.push(
          `<b>${label}</b>\n${helpContent}${remainLine}`
        );
      } else {
        const remainLine = remainStr ? `\n<i>–î–æ –ø–æ–¥—Å–∫–∞–∑–∫–∏ –æ—Å—Ç–∞–ª–æ—Å—å: ${escapeHtml(remainStr)}</i>` : '';
        helpsSections.push(
          `<b>${label}</b>\n<blockquote>${helpContent}</blockquote>${remainLine}`
        );
      }
    } else {
      let section = `${label}\n${helpContent}`;
      if (remainStr) {
        section += `\n–î–æ –ø–æ–¥—Å–∫–∞–∑–∫–∏ –æ—Å—Ç–∞–ª–æ—Å—å: ${remainStr}`;
      }
      helpsSections.push(section);
    }
  }

  const helpsBlock = helpsSections.length > 0
    ? helpsSections.join('\n\n')
    : '';

  const sections = [header];
  if (timeoutLine) {
    sections.push(timeoutLine);
  }
  if (bodyMain) {
    sections.push(bodyMain);
  }
  if (helpsBlock) {
    sections.push(helpsBlock);
  }

  const text = sections.join('\n\n');
  const body = sections.slice(1).join('\n\n');

  return {
    text,
    header,
    body,
    options
  };
}

function splitMessageBody(text, maxLength) {
  if (!text) {
    return [];
  }

  const chunks = [];
  for (let i = 0; i < text.length; i += maxLength) {
    chunks.push(text.slice(i, i + maxLength));
  }
  return chunks;
}

function sanitizeHtmlForTelegram(html) {
  if (!html) {
    return '';
  }

  let text = String(html);

  text = text.replace(/\r\n?/g, '\n');
  text = text.replace(/<br\s*\/?>/gi, '\n');
  text = text.replace(/<\/p>/gi, '\n\n');
  text = text.replace(/<p[^>]*>/gi, '');
  text = text.replace(/<\/?div[^>]*>/gi, '\n');
  text = text.replace(/<li[^>]*>/gi, '\n‚Ä¢ ');
  text = text.replace(/<\/li>/gi, '');
  text = text.replace(/<\/?(ul|ol)[^>]*>/gi, '\n');
  text = text.replace(/<blockquote[^>]*>/gi, '\n');
  text = text.replace(/<\/blockquote>/gi, '\n');
  text = text.replace(/<h([1-6])[^>]*>/gi, '\n<b>');
  text = text.replace(/<\/h[1-6]>/gi, '</b>\n');

  const replacements = [
    { from: /<strong[^>]*>/gi, to: '<b>' },
    { from: /<\/strong>/gi, to: '</b>' },
    { from: /<em[^>]*>/gi, to: '<i>' },
    { from: /<\/em>/gi, to: '</i>' },
    { from: /<ins[^>]*>/gi, to: '<u>' },
    { from: /<\/ins>/gi, to: '</u>' },
    { from: /<u[^>]*>/gi, to: '<u>' },
    { from: /<\/u>/gi, to: '</u>' },
    { from: /<(?:strike|del)[^>]*>/gi, to: '<s>' },
    { from: /<\/(?:strike|del)>/gi, to: '</s>' },
    { from: /<span[^>]*>/gi, to: '' },
    { from: /<\/span>/gi, to: '' },
    { from: /<font[^>]*>/gi, to: '' },
    { from: /<\/font>/gi, to: '' },
    { from: /<pre[^>]*>/gi, to: '\n<pre>' },
    { from: /<\/pre>/gi, to: '</pre>\n' },
    { from: /<code[^>]*>/gi, to: '<code>' },
    { from: /<\/code>/gi, to: '</code>' }
  ];
  for (const { from, to } of replacements) {
    text = text.replace(from, to);
  }

  text = text.replace(/<a\s+[^>]*href=["']([^"']+)["'][^>]*>/gi, '<a href="$1">');
  text = text.replace(/<\/a>/gi, '</a>');

  const allowedTags = new Set(['b', 'i', 'u', 's', 'code', 'pre', 'a']);
  text = text.replace(/<([^>]+)>/gi, (match, inner) => {
    const content = inner.trim();
    if (!content) {
      return '';
    }

    const isClosing = content.startsWith('/');
    let tagBody = isClosing ? content.slice(1).trim() : content;
    const isSelfClosing = tagBody.endsWith('/');
    if (isSelfClosing) {
      tagBody = tagBody.slice(0, -1).trim();
    }
    const tagNameMatch = tagBody.match(/^([a-z0-9]+)/i);
    if (!tagNameMatch) {
      return '';
    }
    const tagName = tagNameMatch[1].toLowerCase();

    if (tagName === 'br') {
      return '\n';
    }

    if (!allowedTags.has(tagName)) {
      return '';
    }

    if (isClosing) {
      return `</${tagName}>`;
    }

    if (tagName === 'a') {
      const hrefMatch = tagBody.match(/href\s*=\s*['"]([^'"]+)['"]/i);
      const href = hrefMatch ? hrefMatch[1] : null;
      if (!href) {
        return '';
      }
      return `<a href="${href}">`;
    }

    return `<${tagName}>`;
  });

  text = text
    .replace(/&nbsp;/gi, ' ')
    .replace(/&quot;/gi, '"')
    .replace(/&#39;/gi, '\'').replace(/&apos;/gi, '\'')
    .replace(/&ndash;/gi, '-')
    .replace(/&mdash;/gi, '-')
    .replace(/&hellip;/gi, '...')
    .replace(/&lt;/gi, '<')
    .replace(/&gt;/gi, '>')
    .replace(/&amp;/gi, '&');

  text = text.replace(/\t+/g, ' ');
  text = text.replace(/\n{3,}/g, '\n\n');

  return text.trim();
}

function stripHtml(input) {
  if (!input) {
    return '';
  }

  let text = String(input);

  text = text.replace(/<br\s*\/?>/gi, '\n');
  text = text.replace(/<\/p>/gi, '\n\n');
  text = text.replace(/<p[^>]*>/gi, '');
  text = text.replace(/<li[^>]*>/gi, '\n‚Ä¢ ');
  text = text.replace(/<\/li>/gi, '');
  text = text.replace(/<\/?ul[^>]*>/gi, '\n');
  text = text.replace(/<\/?ol[^>]*>/gi, '\n');
  text = text.replace(/<\/?blockquote[^>]*>/gi, '\n');
  text = text.replace(/<\/?strong[^>]*>/gi, '');
  text = text.replace(/<\/?em[^>]*>/gi, '');
  text = text.replace(/<\/?span[^>]*>/gi, '');
  text = text.replace(/<\/?div[^>]*>/gi, '\n');
  text = text.replace(/<\/?h\d[^>]*>/gi, '\n');
  text = text.replace(/<\/?table[^>]*>/gi, '\n');
  text = text.replace(/<\/?tr[^>]*>/gi, '\n');
  text = text.replace(/<\/?td[^>]*>/gi, '\t');
  text = text.replace(/<\/?th[^>]*>/gi, '\t');
  text = text.replace(/<[^>]+>/g, '');

  text = text
    .replace(/&nbsp;/gi, ' ')
    .replace(/&quot;/gi, '"')
    .replace(/&#39;/gi, '\'').replace(/&apos;/gi, '\'')
    .replace(/&ndash;/gi, '-')
    .replace(/&mdash;/gi, '-')
    .replace(/&hellip;/gi, '...')
    .replace(/&lt;/gi, '<')
    .replace(/&gt;/gi, '>')
    .replace(/&amp;/gi, '&');

  text = text.replace(/\t+/g, ' ');
  text = text.replace(/\r/g, '');
  text = text.replace(/\n{3,}/g, '\n\n');

  return text.trim();
}

// –£–¥–∞–ª—ë–Ω —Ñ–æ—Ä–º–∞—Ç—Ç–µ—Ä HTML, –ø–æ–∫–∞–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ –∑–∞–¥–∞–Ω–∏—è TaskText
function escapeHtml(text) {
  return String(text || '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–µ–∫—É–Ω–¥ –≤ –¥/—á/–º/—Å –±–µ–∑ –Ω—É–ª–µ–≤—ã—Ö –µ–¥–∏–Ω–∏—Ü
function formatRemain(seconds) {
  const total = Number(seconds) || 0;
  if (total <= 0) return '';
  let s = Math.floor(total);
  const days = Math.floor(s / 86400); s %= 86400;
  const hours = Math.floor(s / 3600); s %= 3600;
  const minutes = Math.floor(s / 60); s %= 60;
  const parts = [];
  if (days > 0) parts.push(`${days}–¥`);
  if (hours > 0) parts.push(`${hours}—á`);
  if (minutes > 0) parts.push(`${minutes}–º`);
  if (s > 0) parts.push(`${s}—Å`);
  return parts.join(' ');
}

// –ü–æ–ø—ã—Ç–∫–∞ –∏–∑–≤–ª–µ—á—å —á–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º—ã–π —Ç–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞ —Å–µ–∫—Ç–æ—Ä–∞ –∏–∑ —Ä–∞–∑–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä
function extractSectorAnswerText(rawAnswer) {
  if (rawAnswer == null) return '';
  if (typeof rawAnswer === 'string') return rawAnswer.trim();
  if (typeof rawAnswer === 'number' || typeof rawAnswer === 'boolean') return String(rawAnswer);
  if (Array.isArray(rawAnswer)) {
    const parts = rawAnswer
      .map(item => extractSectorAnswerText(item))
      .filter(v => v && v.trim().length > 0);
    return parts.join(', ');
  }
  // –û–±—ä–µ–∫—Ç: –ø—Ä–æ–±—É–µ–º —Ç–∏–ø–∏—á–Ω—ã–µ –ø–æ–ª—è
  const candidates = [
    rawAnswer.Value,
    rawAnswer.Text,
    rawAnswer.Answer,
    rawAnswer.Display,
    rawAnswer.StringValue,
    rawAnswer.Name,
    rawAnswer.Title,
    rawAnswer.Content
  ].filter(v => v != null);
  if (candidates.length > 0) {
    const first = candidates.find(v => typeof v === 'string') ?? candidates[0];
    return extractSectorAnswerText(first);
  }
  // –ü–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–ø—ã—Ç–∫–∞: —Å–µ—Ä–∏–∞–ª–∏–∑—É–µ–º –ø—Ä–æ—Å—Ç—ã–µ –ø–ª–æ—Å–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
  try {
    const flat = Object.values(rawAnswer)
      .map(v => (typeof v === 'string' || typeof v === 'number' ? String(v) : ''))
      .filter(Boolean)
      .join(' ')
      .trim();
    return flat;
  } catch (_) {
    return '';
  }
}

/**
 * –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ whitelist
 * @param {string} platform - –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
 * @param {string} userId - ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤–Ω—É—Ç—Ä–∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
 * @returns {boolean} - true –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ whitelist –∏–ª–∏ –º–æ–¥–µ—Ä–∞—Ü–∏—è –≤—ã–∫–ª—é—á–µ–Ω–∞
 */
function isUserAllowed(platform, userId) {
  // –ï—Å–ª–∏ –º–æ–¥–µ—Ä–∞—Ü–∏—è –≤—ã–∫–ª—é—á–µ–Ω–∞ - —Ä–∞–∑—Ä–µ—à–∞–µ–º –≤—Å–µ–º
  if (!adminConfig.moderationEnabled) {
    return true;
  }

  const user = getPlatformUser(platform, userId);

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ Encounter login
  if (user.login) {
    if (whitelistCache.has(user.login.toLowerCase())) {
      return true;
    }
  }

  return false;
}

/**
 * –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∏–≥—Ä–æ–≤—ã–º —Ñ—É–Ω–∫—Ü–∏—è–º
 * @param {string} platform - –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
 * @param {string} userId - ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 * @returns {boolean} - true –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø —Ä–∞–∑—Ä–µ—à–µ–Ω
 */
async function checkGameAccess(platform, userId) {
  if (isUserAllowed(platform, userId)) {
    return true;
  }

  // –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω - –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
  await sendMessage(platform, userId, 'üö´ –î–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –Ω–µ —Ä–∞–∑—Ä–µ—à–µ–Ω. –°–≤—è–∂–∏—Ç–µ—Å—å —Å @seo2z');
  return false;
}

// Throttling –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π —Å–æ–æ–±—â–µ–Ω–∏–π (–∑–∞—â–∏—Ç–∞ –æ—Ç rate limiting)
const MESSAGE_THROTTLE_TTL = 60_000;
const messageUpdateThrottle = new Map(); // `${platform}_${userId}_${messageId}` -> { lastUpdate, pendingText, pendingOptions, timeout, cleanupTimeout }

function scheduleThrottleCleanup(throttleKey, entry) {
  if (!entry) {
    return;
  }

  if (entry.cleanupTimeout) {
    clearTimeout(entry.cleanupTimeout);
    entry.cleanupTimeout = null;
  }

  entry.cleanupTimeout = setTimeout(() => {
    const current = messageUpdateThrottle.get(throttleKey);
    if (!current) {
      return;
    }

    if (!current.timeout && (current.pendingText === null || current.pendingText === undefined)) {
      messageUpdateThrottle.delete(throttleKey);
    } else {
      // –ë—ã–ª–æ –æ—Ç–ª–æ–∂–µ–Ω–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ ‚Äî –ø–æ–ø—Ä–æ–±—É–µ–º –µ—â—ë —Ä–∞–∑ –ø–æ–∑–∂–µ
      scheduleThrottleCleanup(throttleKey, current);
    }
  }, MESSAGE_THROTTLE_TTL);
}

async function sendOrUpdateMessage(platform, userId, text, messageId = null, options = {}) {
  try {
    if (messageId) {
      const throttleKey = `${platform}_${userId}_${messageId}`;
      const now = Date.now();
      const throttle = messageUpdateThrottle.get(throttleKey);

      if (throttle) {
        const elapsed = now - throttle.lastUpdate;

        if (elapsed < 2000) {
          console.log(`‚è≥ Throttle: –æ—Ç–∫–ª–∞–¥—ã–≤–∞—é –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è (–ø—Ä–æ—à–ª–æ ${elapsed}ms < 2000ms)`);

          if (throttle.timeout) {
            clearTimeout(throttle.timeout);
          }

          throttle.pendingText = text;
          throttle.pendingOptions = options;

          const waitTime = 2000 - elapsed;
          if (throttle.cleanupTimeout) {
            clearTimeout(throttle.cleanupTimeout);
            throttle.cleanupTimeout = null;
          }

          throttle.timeout = setTimeout(async () => {
            try {
              await editPlatformMessage(platform, userId, messageId, throttle.pendingText, throttle.pendingOptions || {});
              throttle.lastUpdate = Date.now();
              throttle.pendingText = null;
              throttle.pendingOptions = null;
              throttle.timeout = null;
              console.log('‚úÖ –û—Ç–ª–æ–∂–µ–Ω–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–æ');
              scheduleThrottleCleanup(throttleKey, throttle);
            } catch (err) {
              if (err.code === 'ETELEGRAM' && err.response?.body?.description?.includes('message is not modified')) {
                console.log('‚è≠Ô∏è –û—Ç–ª–æ–∂–µ–Ω–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å');
              } else if (err.response?.statusCode === 429) {
                console.log('‚ö†Ô∏è Rate limit –ø—Ä–∏ –æ—Ç–ª–æ–∂–µ–Ω–Ω–æ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º');
              } else {
                console.error('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ª–æ–∂–µ–Ω–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:', err.message);
              }
              throttle.pendingText = null;
              throttle.pendingOptions = null;
              throttle.timeout = null;
              scheduleThrottleCleanup(throttleKey, throttle);
            }
          }, waitTime);

          return messageId;
        }
      }

      await editPlatformMessage(platform, userId, messageId, text, options);

      messageUpdateThrottle.set(throttleKey, {
        lastUpdate: Date.now(),
        pendingText: null,
        pendingOptions: null,
        timeout: null,
        cleanupTimeout: null
      });
      scheduleThrottleCleanup(throttleKey, messageUpdateThrottle.get(throttleKey));

      return messageId;
    }

    return await sendPlatformMessage(platform, userId, text, options);
  } catch (error) {
    if (error.code === 'ETELEGRAM' && error.response?.body?.description?.includes('message is not modified')) {
      console.log('‚è≠Ô∏è –°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ');
      return messageId;
    }

    if (error.response?.statusCode === 429) {
      console.log('‚ö†Ô∏è Rate limit (429), –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è');
      return messageId;
    }

    if (messageId && /–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç editMessage/i.test(error.message || '')) {
      console.log(`[${platform}] –¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π, –æ—Ç–ø—Ä–∞–≤–ª—è—é –Ω–æ–≤–æ–µ`);
      return await sendPlatformMessage(platform, userId, text, options);
    }

    if (messageId && error.response?.status === 400) {
      console.log('üì§ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤–º–µ—Å—Ç–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è');
      return await sendPlatformMessage(platform, userId, text, options);
    }

    throw error;
  }
}

// –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞ –≤ –∏–≥—Ä—É Encounter
// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ —Å—Å—ã–ª–∫–∏ –Ω–∞ –∏–≥—Ä—É
function parseGameUrl(url) {
  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å —Å—Å—ã–ª–∫–∏ –∏ –∏–∑–≤–ª–µ–∫–∞–µ–º –¥–æ–º–µ–Ω –∏ ID –∏–≥—Ä—ã
    const urlObj = new URL(url);
    const domain = `${urlObj.protocol}//${urlObj.hostname}`;
    
    // –¢–∏–ø 1: https://tech.en.cx/GameDetails.aspx?gid=80646
    if (urlObj.pathname.includes('/GameDetails.aspx') && urlObj.searchParams.has('gid')) {
      const gameId = urlObj.searchParams.get('gid');
      return {
        success: true,
        domain: domain,
        gameId: gameId,
        type: 'GameDetails'
      };
    }
    
    // –¢–∏–ø 2: https://tech.en.cx/gameengines/encounter/play/80646/
    const playMatch = urlObj.pathname.match(/\/gameengines\/encounter\/play\/(\d+)\/?$/);
    if (playMatch) {
      return {
        success: true,
        domain: domain,
        gameId: playMatch[1],
        type: 'Play'
      };
    }
    
    return {
      success: false,
      message: '–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞ –Ω–∞ –∏–≥—Ä—É. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ:\n‚Ä¢ https://domain.en.cx/GameDetails.aspx?gid=XXXXX\n‚Ä¢ https://domain.en.cx/gameengines/encounter/play/XXXXX/'
    };
    
  } catch (error) {
    return {
      success: false,
      message: '–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—Å—ã–ª–∫–∏. –ü—Ä–∏–º–µ—Ä: https://tech.en.cx/GameDetails.aspx?gid=80646'
    };
  }
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
async function checkAuthentication(login, password, domain = 'https://world.en.cx') {
  try {
    const api = new EncounterAPI(domain);
    const result = await api.authenticate(login, password);
    return result; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ–ª–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç, –∞ –Ω–µ —Ç–æ–ª—å–∫–æ success
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:', error.message);
    // –ï—Å–ª–∏ –Ω–µ—Ç –¥–æ–º–µ–Ω–∞, –ø—Ä–∏–Ω–∏–º–∞–µ–º –±–∞–∑–æ–≤—É—é –ø—Ä–æ–≤–µ—Ä–∫—É
    return {
      success: login.length > 0 && password.length > 0,
      message: login.length > 0 && password.length > 0 ? '–ë–∞–∑–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–π–¥–µ–Ω–∞' : '–õ–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º–∏'
    };
  }
}

/**
 * –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π
 */
async function showUsersList(chatId, messageId, page = 0) {
  const USERS_PER_PAGE = 10;
  const users = Array.from(userData.entries());
  const totalPages = Math.ceil(users.length / USERS_PER_PAGE);
  const start = page * USERS_PER_PAGE;
  const end = start + USERS_PER_PAGE;
  const pageUsers = users.slice(start, end);

  if (users.length === 0) {
    const message = 'üë• <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏</b>\n\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ–∫–∞ –Ω–µ—Ç';
    const keyboard = {
      inline_keyboard: [[{ text: '‚óÄÔ∏è –ù–∞–∑–∞–¥', callback_data: 'admin_back' }]]
    };

    await editTelegramMessage(message, {
      chat_id: chatId,
      message_id: messageId,
      parse_mode: 'HTML',
      reply_markup: keyboard
    });
    return;
  }

  let message = `üë• <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏</b> (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ ${page + 1}/${totalPages})\n\n`;

  for (const [storageKey, user] of pageUsers) {
    const [keyPlatform, ...restKey] = storageKey.split('::');
    const platform = user.platform || keyPlatform || TELEGRAM_PLATFORM;
    const plainUserId = user.userId || (restKey.length > 0 ? restKey.join('::') : storageKey);
    const username = user.telegramUsername ? `@${user.telegramUsername}` : user.telegramFirstName || '–ë–µ–∑ –∏–º–µ–Ω–∏';
    const login = user.login || '‚Äî';
    const firstActivity = user.firstActivity ? new Date(user.firstActivity).toLocaleDateString('ru-RU') : '‚Äî';
    const lastActivity = user.lastActivity ? new Date(user.lastActivity).toLocaleString('ru-RU') : '‚Äî';

    message += `<b>${username}</b>\n`;
    message += `ID: <code>${plainUserId}</code>\n`;
    message += `–ü–ª–∞—Ç—Ñ–æ—Ä–º–∞: ${platform}\n`;
    message += `–õ–æ–≥–∏–Ω EN: <code>${login}</code>\n`;
    message += `–ü–µ—Ä–≤—ã–π –≤—Ö–æ–¥: ${firstActivity}\n`;
    message += `–ü–æ—Å–ª–µ–¥–Ω–∏–π: ${lastActivity}\n\n`;
  }

  // –ö–Ω–æ–ø–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
  const keyboard = { inline_keyboard: [] };
  const navButtons = [];

  if (page > 0) {
    navButtons.push({ text: '‚óÄÔ∏è –ù–∞–∑–∞–¥', callback_data: `admin_users_${page - 1}` });
  }
  if (page < totalPages - 1) {
    navButtons.push({ text: '–í–ø–µ—Ä–µ–¥ ‚ñ∂Ô∏è', callback_data: `admin_users_${page + 1}` });
  }

  if (navButtons.length > 0) {
    keyboard.inline_keyboard.push(navButtons);
  }

  keyboard.inline_keyboard.push([{ text: 'üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é', callback_data: 'admin_back' }]);

  await editTelegramMessage(message, {
    chat_id: chatId,
    message_id: messageId,
    parse_mode: 'HTML',
    reply_markup: keyboard
  });
}

/**
 * –ü–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º–æ–¥–µ—Ä–∞—Ü–∏–µ–π
 */
async function showModerationMenu(chatId, messageId) {
  const status = adminConfig.moderationEnabled ? '–≤–∫–ª—é—á–µ–Ω–∞ ‚úÖ' : '–≤—ã–∫–ª—é—á–µ–Ω–∞ ‚ùå';
  const buttonText = adminConfig.moderationEnabled ? '‚ùå –í—ã–∫–ª—é—á–∏—Ç—å' : '‚úÖ –í–∫–ª—é—á–∏—Ç—å';

  const message = `üîê <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ–¥–µ—Ä–∞—Ü–∏–µ–π</b>\n\n` +
    `–¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å: ${status}\n\n` +
    `–ö–æ–≥–¥–∞ –º–æ–¥–µ—Ä–∞—Ü–∏—è –≤–∫–ª—é—á–µ–Ω–∞, –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –∏–º–µ—é—Ç —Ç–æ–ª—å–∫–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –∏–∑ –±–µ–ª–æ–≥–æ —Å–ø–∏—Å–∫–∞.`;

  const keyboard = {
    inline_keyboard: [
      [{ text: buttonText, callback_data: 'moderation_toggle' }],
      [{ text: '‚óÄÔ∏è –ù–∞–∑–∞–¥', callback_data: 'admin_back' }]
    ]
  };

  await editTelegramMessage(message, {
    chat_id: chatId,
    message_id: messageId,
    parse_mode: 'HTML',
    reply_markup: keyboard
  });
}

/**
 * –ü–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–µ–ª—ã–º —Å–ø–∏—Å–∫–æ–º
 */
async function showWhitelistMenu(chatId, messageId, page = 0) {
  const ITEMS_PER_PAGE = 10;
  const whitelist = adminConfig.whitelist || [];
  const totalPages = Math.ceil(whitelist.length / ITEMS_PER_PAGE);
  const start = page * ITEMS_PER_PAGE;
  const end = start + ITEMS_PER_PAGE;
  const pageItems = whitelist.slice(start, end);

  let message = `üìã <b>–ë–µ–ª—ã–π —Å–ø–∏—Å–æ–∫</b>\n\n`;

  if (whitelist.length === 0) {
    message += '–ë–µ–ª—ã–π —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç\n\n';
    message += '–ù–∞–∂–º–∏—Ç–µ "–î–æ–±–∞–≤–∏—Ç—å", —á—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è';
  } else {
    message += `–°—Ç—Ä–∞–Ω–∏—Ü–∞ ${page + 1}/${totalPages}\n\n`;

    for (let i = 0; i < pageItems.length; i++) {
      const item = pageItems[i];
      const globalIndex = start + i;
      // –ü–æ–ª—É—á–∞–µ–º –ª–æ–≥–∏–Ω –∏–∑ –Ω–æ–≤–æ–≥–æ –∏–ª–∏ —Å—Ç–∞—Ä–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞
      const login = item.login || (item.type === 'encounter' ? item.value : item.value);
      message += `${globalIndex + 1}. üéÆ <code>${login}</code>\n`;
    }
  }

  // –ö–Ω–æ–ø–∫–∏
  const keyboard = { inline_keyboard: [] };

  // –ö–Ω–æ–ø–∫–∏ —É–¥–∞–ª–µ–Ω–∏—è (—Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 5 –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞)
  const removeButtons = [];
  for (let i = 0; i < Math.min(pageItems.length, 5); i++) {
    const globalIndex = start + i;
    removeButtons.push({
      text: `üóëÔ∏è ${globalIndex + 1}`,
      callback_data: `whitelist_remove_${globalIndex}`
    });
  }

  if (removeButtons.length > 0) {
    // –†–∞–∑–±–∏–≤–∞–µ–º –ø–æ 3 –∫–Ω–æ–ø–∫–∏ –≤ —Ä—è–¥
    for (let i = 0; i < removeButtons.length; i += 3) {
      keyboard.inline_keyboard.push(removeButtons.slice(i, i + 3));
    }
  }

  // –ù–∞–≤–∏–≥–∞—Ü–∏—è
  const navButtons = [];
  if (page > 0) {
    navButtons.push({ text: '‚óÄÔ∏è', callback_data: `admin_whitelist_${page - 1}` });
  }
  navButtons.push({ text: '‚ûï –î–æ–±–∞–≤–∏—Ç—å', callback_data: 'whitelist_add' });
  if (page < totalPages - 1) {
    navButtons.push({ text: '‚ñ∂Ô∏è', callback_data: `admin_whitelist_${page + 1}` });
  }

  keyboard.inline_keyboard.push(navButtons);
  keyboard.inline_keyboard.push([{ text: '‚óÄÔ∏è –ù–∞–∑–∞–¥', callback_data: 'admin_back' }]);

  await editTelegramMessage(message, {
    chat_id: chatId,
    message_id: messageId,
    parse_mode: 'HTML',
    reply_markup: keyboard
  });
}

/**
 * –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ whitelist
 */
async function handleWhitelistAdd(chatId, messageId) {
  const message = `‚ûï <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –±–µ–ª—ã–π —Å–ø–∏—Å–æ–∫</b>\n\n` +
    `–û—Ç–ø—Ä–∞–≤—å—Ç–µ Encounter –ª–æ–≥–∏–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:\n\n` +
    `–ü—Ä–∏–º–µ—Ä: <code>player123</code>`;

  const keyboard = {
    inline_keyboard: [[{ text: '‚ùå –û—Ç–º–µ–Ω–∞', callback_data: 'admin_whitelist_0' }]]
  };

  await editTelegramMessage(message, {
    chat_id: chatId,
    message_id: messageId,
    parse_mode: 'HTML',
    reply_markup: keyboard
  });

  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –æ–∂–∏–¥–∞–Ω–∏—è –≤–≤–æ–¥–∞
  setUserState(TELEGRAM_PLATFORM, String(chatId), 'WAITING_FOR_WHITELIST_ENTRY');
}

/**
 * –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∏–∑ whitelist
 */
async function showAdminMainMenu(chatId) {
  const usersCount = userData.size;
  const moderationStatus = adminConfig.moderationEnabled ? '–≤–∫–ª—é—á–µ–Ω–∞ ‚úÖ' : '–≤—ã–∫–ª—é—á–µ–Ω–∞ ‚ùå';
  const whitelistCount = adminConfig.whitelist ? adminConfig.whitelist.length : 0;

  const message = `üëë <b>–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å</b>\n\n` +
    `üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: ${usersCount}\n` +
    `üîê –ú–æ–¥–µ—Ä–∞—Ü–∏—è: ${moderationStatus}\n` +
    `üìã –ë–µ–ª—ã–π —Å–ø–∏—Å–æ–∫: ${whitelistCount} –∑–∞–ø–∏—Å–µ–π`;

  const keyboard = {
    inline_keyboard: [
      [{ text: 'üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏', callback_data: 'admin_users_0' }],
      [{ text: 'üîê –ú–æ–¥–µ—Ä–∞—Ü–∏—è', callback_data: 'admin_moderation' }],
      [{ text: 'üìã –ë–µ–ª—ã–π —Å–ø–∏—Å–æ–∫', callback_data: 'admin_whitelist_0' }]
    ]
  };

  try {
    await sendMessage(TELEGRAM_PLATFORM, chatId, message, {
      parse_mode: 'HTML',
      reply_markup: keyboard
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∞–¥–º–∏–Ω-–º–µ–Ω—é:', error);
    await sendMessage(TELEGRAM_PLATFORM, chatId, '‚ùå –û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏');
  }
}

async function handleWhitelistRemove(chatId, messageId, index, queryId = null) {
  if (!adminConfig.whitelist || index < 0 || index >= adminConfig.whitelist.length) {
    if (queryId) {
      await answerTelegramCallback(queryId, {
        text: '‚ùå –û—à–∏–±–∫–∞: –∑–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞',
        show_alert: true
      });
    }
    return;
  }

  // –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å
  adminConfig.whitelist.splice(index, 1);
  await saveAdminConfig();

  // –û–±–Ω–æ–≤–ª—è–µ–º –º–µ–Ω—é
  await showWhitelistMenu(chatId, messageId, 0);
}

let handlersRegistered = false;
function registerTelegramHandlers() {
  if (handlersRegistered) {
    return;
  }
  if (!bot) {
    throw new Error('Telegram –±–æ—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤');
  }
  handlersRegistered = true;

  const commandList = ['reset', 'test', 'admin', 'cancel', 'start'];

  commandList.forEach((command) => {
    const regex = new RegExp(`\\/${command}(?:\\s+(.*))?$`, 'i');
    bot.onText(regex, async (msg, match) => {
      const args = match && match[1] ? match[1].trim() : '';
      const context = createTelegramContext(msg, {
        commandName: command,
        args
      });

      try {
        await handleCommand(context);
      } catch (error) {
        console.error(`[telegram] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–º–∞–Ω–¥—ã /${command}:`, error);
      }
    });
  });

  bot.on('callback_query', async (query) => {
    const context = createTelegramCallbackContext(query);
    try {
      await handleCallback(context);
    } catch (error) {
      console.error('[telegram] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ callback_query:', error);
    }
  });

  bot.on('message', async (msg) => {
    const context = createTelegramContext(msg);
    try {
      await handleTextMessage(context);
    } catch (error) {
      console.error('[telegram] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è:', error);
    }
  });
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
// –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
async function startBot() {
  await loadUserData();
  await loadAdminConfig();
  await telegramAdapter.start();
  bot = telegramAdapter.getBot();

  bot.on('error', (error) => {
    console.error('–û—à–∏–±–∫–∞ –±–æ—Ç–∞:', error);
  });

  bot.on('polling_error', (error) => {
    console.error('–û—à–∏–±–∫–∞ polling:', error);
  });

  registerTransport(TELEGRAM_PLATFORM, {
    sendMessage: (userId, text, options = {}) => bot.sendMessage(userId, text, options),
    editMessage: (userId, messageId, text, options = {}) => bot.editMessageText(text, {
      chat_id: userId,
      message_id: messageId,
      ...(options || {})
    }),
    deleteMessage: (userId, messageId) => bot.deleteMessage(userId, messageId),
    sendTyping: (userId) => bot.sendChatAction ? bot.sendChatAction(userId, 'typing') : Promise.resolve(),
    answerCallback: ({ queryId, ...options }) => bot.answerCallbackQuery(queryId, options)
  });

  ({
    sendToEncounterAPI,
    sendAnswerToEncounter,
    processAnswerQueue
  } = createAnswerService({
    EncounterAPI,
    sendMessage: sendPlatformMessage,
    sendOrUpdateMessage,
    saveUserData,
    getUserInfo,
    getAnswerQueue,
    enqueueAnswer
  }));

  registerTelegramHandlers();
  console.log('ü§ñ Telegram-–±–æ—Ç en_off_bot –∑–∞–ø—É—â–µ–Ω!');
  console.log('üì± –ì–æ—Ç–æ–≤ –∫ –ø—Ä–∏–µ–º—É —Å–æ–æ–±—â–µ–Ω–∏–π...');

  if (VK_GROUP_TOKEN && VK_GROUP_ID) {
    try {
      vkAdapterInstance = new VkAdapter({
        token: VK_GROUP_TOKEN,
        groupId: VK_GROUP_ID
      });

      await vkAdapterInstance.start();

      const toPeerId = (userId, options = {}) => {
        if (typeof userId === 'number') {
          return userId;
        }

        if (typeof userId === 'string' && userId.trim() !== '') {
          const parsed = Number(userId);
          if (!Number.isNaN(parsed) && parsed !== 0) {
            return parsed;
          }
        }

        const fromOptions = options.peerId ?? options.peer_id ?? options.meta?.peerId;
        if (fromOptions != null) {
          const parsed = Number(fromOptions);
          if (!Number.isNaN(parsed) && parsed !== 0) {
            return parsed;
          }
        }

        throw new Error('[vk] –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å peerId');
      };

      registerTransport(VK_PLATFORM, {
        sendMessage: async (userId, text, options = {}) => {
          const peerId = toPeerId(userId, options);
          const safeText = text == null ? '' : String(text);
          const { keyboard, conversationMessageId, messageId, ...meta } = options || {};
          const response = await vkAdapterInstance.sendMessage(
            { peerId, conversationMessageId, messageId },
            {
              type: OutboundMessageType.TEXT,
              text: safeText,
              keyboard,
              meta
            }
          );
          return {
            message_id: response.message_id ?? response,
            peer_id: response.peer_id ?? peerId,
            conversation_message_id: response.conversation_message_id ?? conversationMessageId ?? null
          };
        },
        editMessage: async (userId, messageId, text, options = {}) => {
          const peerId = toPeerId(userId, options);
          const safeText = text == null ? '' : String(text);
          const { keyboard, conversationMessageId, ...meta } = options || {};

          await vkAdapterInstance.updateMessage(
            { peerId, messageId, conversationMessageId },
            {
              type: OutboundMessageType.EDIT,
              text: safeText,
              keyboard,
              meta
            }
          );

          return {
            message_id: messageId,
            peer_id: peerId,
            conversation_message_id: conversationMessageId ?? null
          };
        },
        sendTyping: async (userId, options = {}) => {
          try {
            const peerId = toPeerId(userId, options);
            await vkAdapterInstance.vk.api.messages.sendActivity({
              peer_id: peerId,
              type: 'typing'
            });
          } catch (_) {
            // ignore typing capabilities absence
          }
        }
      });

      vkAdapterInstance.onEvent(async (event) => {
        try {
          if (event.type === PlatformEventType.COMMAND) {
            await handleCommand({
              platform: event.platform,
              userId: event.userId,
              text: event.text || '',
              commandName: event.meta?.commandName || '',
              args: event.meta?.args || '',
              meta: event.meta || {},
              from: event.meta?.from || {
                id: event.meta?.fromId
              }
            });
          } else if (event.type === PlatformEventType.CALLBACK) {
            await handleCallback({
              platform: event.platform,
              userId: event.userId,
              payload: event.payload,
              meta: event.meta || {}
            });
          } else {
            await handleTextMessage({
              platform: event.platform,
              userId: event.userId,
              text: event.text || '',
              meta: event.meta || {},
              from: event.meta?.from || {
                id: event.meta?.fromId
              }
            });
          }
        } catch (error) {
          console.error('[vk] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏—è:', error);
        }
      });

      console.log('üåê VK-–ø–ª–∞—Ç—Ñ–æ—Ä–º–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∞ –∏ –≥–æ—Ç–æ–≤–∞ –∫ —Ä–∞–±–æ—Ç–µ');
    } catch (error) {
      console.error('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å VK –∞–¥–∞–ø—Ç–µ—Ä:', error);
    }
  } else {
    console.log('‚ÑπÔ∏è VK –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞ (–Ω–µ—Ç VK_GROUP_TOKEN –∏–ª–∏ VK_GROUP_ID)');
  }
}

startBot();

// –ì—Ä–∞—Ü–∏–æ–∑–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã
process.on('SIGINT', async () => {
  console.log('\nüõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞...');
  await saveUserData();
  await telegramAdapter.stop().catch(() => {});
  if (vkAdapterInstance) {
    await vkAdapterInstance.stop().catch(() => {});
  }
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('\nüõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞...');
  await saveUserData();
  await telegramAdapter.stop().catch(() => {});
  if (vkAdapterInstance) {
    await vkAdapterInstance.stop().catch(() => {});
  }
  process.exit(0);
});


