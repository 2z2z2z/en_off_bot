# План рефакторинга

## Требования к выполнению фаз

- Перед выполнением каждой фазы необходимо обладать 100% контекстом по проекту и состоянию рефакторинга.
- После выполнения каждой фазы:
  1. Запускать `npm run lint` и `npm test`, переходить к следующему пункту только если все ок. Если есть проблемы - устранить;
  2. Отметить выполненные пункты в текущем документе;
  3. Обновить `impl.md`, добавив техническую реализацию выполненных шагов;
  4. При необходимости обновлять также `docs\architecture-scheme.md` (следить за тем что в плане и что надо актуализировать);
  5. Предложить следующие действия;
  6. Остановиться.
- Работать строго по чекам плана; при невозможности или нахождении альтернативного решения (более лучшего или оптимизированного) — остановиться, сообщить о проблеме или альтернативном решении и предложить варианты.

## Фазы

- [x] **Фаза 0: Инфраструктура и защита от регрессий (КРИТИЧНО — выполнить ПЕРВЫМ)**
  - [x] **Логирование:** Установить и настроить pino logger, заменить все console.log/error на структурированное логирование с уровнями (debug, info, warn, error)
  - [x] **Smoke-тесты:** Написать 10-15 базовых тестов для критических функций:
    - `parseGameUrl` (различные форматы URL)
    - Burst detection логика (временные окна, накопление)
    - Queue processor (добавление, обработка, retry)
    - Level change detection
    - Cookie updates и сохранение
  - [x] **ESLint + Prettier:** Настроить линтер и форматтер, добавить npm scripts (lint, format, test)
  - [x] **Production-подобный датасет:** Создать тестовый user_data.json с 100+ пользователями для тестирования производительности
  - [x] **Целевая структура директорий:** Зафиксировать архитектуру в документе для согласования перед началом рефакторинга

- [x] **Фаза 1: Архитектурная сетка и декомпозиция точки входа** (см. [раздел 3.1](refactoring.md#31-декомпозиция-точки-входа))
  - [x] Зафиксировать целевую FSD-схему в `docs/architecture-scheme.md`.
  - [x] Подготовить базовую структуру директорий (`src/app`, `src/processes`, `src/features`, `src/entities`, `src/shared`).
  - [x] Вынести загрузку окружения, данных и graceful shutdown в `src/app/bootstrap`.
  - [x] Реализовать `bot-engine` (регистрация транспортов, запуск адаптеров) в `src/app/providers`.
  - [x] Вынести обработчики команд, текстов и callback'ов в `src/features` (answer, auth, admin) с единым event router.
  - [x] Обновить `src/app/index.js`, оставив только сборку зависимостей и запуск.

- [x] **Фаза 2: Доменные сервисы потоков ответов** (см. [раздел 3.2](refactoring.md#32-сервисный-слой-ответов-и-потоков))
- [x] **Фаза 2.1: Декомпозиция метода sendAnswerToEncounter (259 строк — ПРИОРИТЕТ)**
  - [x] Выделить `checkPendingDecisions()` — проверка pendingQueueDecision/pendingAnswerDecision
  - [x] Выделить `detectLevelChange()` — обнаружение смены уровня и создание подтверждений
  - [x] Выделить `retryWithBackoff()` — retry-логика с экспоненциальным backoff
  - [x] Выделить `updateProgressMessage()` — обновление progress-сообщений для пользователя
  - [x] Выделить `handleCookieUpdate()` — обработка и сохранение обновлённых cookies
  - [x] Написать unit-тесты для каждой выделенной функции

  - [x] **Фаза 2.2: Остальные модули answer-service**
    - [x] Выделить `answer-delivery` с контролем уровня и форматированием ответов
    - [x] Реализовать `queue-processor` с отдельными политиками повторов и уведомлений
    - [x] Вынести `burst-detector` и `batch-buffer` в самостоятельные модули
    - [x] Определить и задокументировать контракт взаимодействия сервисов с userStore/messenger

  - [x] **Фаза 2.3: Декомпозиция сложных функций**
    - [x] Разбить `createAnswerDelivery` на специализированные модули (форматирование, ошибки, накопления)
    - [x] Разбить `processAnswerQueue` на подфункции (инициализация, обработка элемента, финализация)
    - [x] Снизить метрики `complexity`/`max-lines` до уровня предупреждений линтера
    - [x] Обновить/добавить тесты для выделенных блоков

- [x] **Фаза 3: Миграция на SQLite** (КРИТИЧНО для production масштаба — см. [раздел 3.3](refactoring.md#33-управление-данными-пользователей))

  **Обоснование:** При 100-500+ пользователях JSON вырастет до 5-10MB с критическими проблемами: полная загрузка в память, перезапись всего файла, отсутствие транзакций, race conditions, O(n) поиск.
  - [x] **Проектирование схемы БД:**
    - [x] Создать таблицы: `profiles` (пользователи), `game_sessions` (игры), `runtime_state` (очереди/буферы)
    - [x] Добавить индексы: `idx_user_platform`, `idx_game_id`, `idx_profile_session`
    - [x] Настроить Foreign Keys с CASCADE DELETE для автоматической очистки
    - [x] Добавить таблицу `schema_version` для версионирования миграций

  - [x] **Реализация репозитория:**
    - [x] Создать класс `UserRepository` с методами:
      - `getProfile(userId, platform)`, `saveProfile(profile)`
      - `getGameSession(profileId, gameId)`, `updateAuthCookies(sessionId, cookies)`
      - `getRuntimeState(profileId)`, `updateRuntimeState(profileId, state)`
      - `cleanupOldTimestamps(maxAge)`, `deleteInactiveStates(days)`
    - [x] Обернуть все операции записи в транзакции
    - [x] Добавить валидацию данных перед сохранением (обязательные поля, типы, лимиты)

  - [x] **TTL и автоматическая очистка:**
    - [x] Реализовать фоновую задачу (setInterval 6-12ч):
      - Удаление timestamp'ов старше 24 часов
      - Очистка завершённых накоплений
      - Удаление неактивных runtime_state (>30 дней без обновлений)
    - [x] Ограничить размер буферов (max 100 элементов в pending_answers)

  - [x] **Скрипт миграции данных:**
    - [x] Создать `scripts/migrate-json-to-sqlite.js` для переноса существующего user_data.json
    - [x] Проверка целостности после миграции (количество пользователей, профилей, сессий)
    - [x] Создание backup JSON перед миграцией

  - [x] **Параллельный режим и тестирование:**
    - [x] Реализовать dual-write: запись в JSON + SQLite одновременно
    - [x] Тестирование на production-подобном датасете (100+ пользователей)
    - [x] Performance тесты: 500 пользователей, 1000 операций чтения/записи
    - [x] Stress-тесты: concurrent writes от Telegram и VK

  - [x] **Постепенный переход:**
    - [x] Включить чтение из SQLite (fallback на JSON при ошибках)
    - [x] Мониторинг ошибок и производительности 1-2 недели
    - [x] Отключить запись в JSON (только чтение для rollback)
    - [x] Финализация: отключить JSON полностью, сохранить как архив

  - [x] **Rollback план:**
    - [x] Реализовать export из SQLite обратно в JSON
    - [x] Документировать процедуру возврата к JSON
    - [x] Сохранять бэкапы SQLite после каждой критической операции

- [x] **Фаза 4: Улучшение Encounter API** (см. [раздел 3.4](refactoring.md#34-перестройка-encounter-api))

  **Текущее состояние:** Rate limiter, кеш уровней, authCallback с мьютексом уже реализованы хорошо.
    - [x] **Кастомные классы ошибок:**
      - [x] Создать `src/core/encounter-errors.js` с иерархией:
        - `EncounterError` (базовый)
        - `LevelChangedError` (смена уровня)
        - `AuthRequiredError` (требуется реавторизация)
        - `NetworkError` (сетевые проблемы)
      - [x] Заменить текстовые сравнения ошибок на instanceof проверки
      - [x] Обновить answer-service для работы с новыми классами ошибок
    - [ ] **Нормализация авторизации (`authenticate`):**
      - [x] Задействовать `_normalizeAuthResponse` и `_normalizeAuthError`, убрать дублирование логики
      - [x] Сохранять HTML-ответы при блокировке IP через `_saveErrorHtml`
      - [x] Расширить тесты авторизации (IP_BLOCKED, HTML-ответы) и интегрировать проверку в smoke-набор

    - [x] **Интеграция структурированного логирования:**
      - [x] Заменить console.log/error на pino logger (из фазы 0)
      - [x] Добавить контекст запросов (userId, gameId, level) в логи
    - [x] **Унификация сетевых ошибок Encounter:**
      - [x] Вынести нормализацию axios-ошибок в `_normalizeNetworkError`
      - [x] Подключить хелпер к `getGameState` и `sendAnswer`
      - [x] Использовать хелпер в прочих методах (`getGamesList`, `checkConnection`, `getGameInfo`)

- [ ] **Фаза 5: Presentation-слой** (минимальные правки — см. [раздел 3.5](refactoring.md#35-платформенные-адаптеры-и-событийная-шина))

  **Текущее состояние:** PlatformAdapter и событийная архитектура УЖЕ реализованы на 80-90%.
  - [ ] **Фабрика клавиатур:**
    - [ ] Создать `src/presentation/keyboard-factory.js`:
      - `createInlineKeyboard(buttons, platform)` — inline-клавиатуры telegram/vk
      - `createReplyKeyboard(buttons, platform)` — reply-клавиатуры
    - [ ] Заменить разбросанные `if (platform === 'telegram')` на вызовы фабрики

  - [ ] **Форматирование сообщений:**
    - [ ] Создать `src/presentation/message-formatter.js`:
      - `formatLevelInfo(levelData, platform)` — HTML для Telegram, plain text для VK
      - `formatProgress(progress, platform)` — форматирование прогресса
      - `formatError(error, platform)` — форматирование ошибок
    - [ ] Вынести форматирование из бизнес-логики в presentation-слой

- [ ] **Фаза 6: Whitelist и админка** (средний приоритет — см. [раздел 3.6](refactoring.md#36-админка-и-whitelist))
  - [ ] Вынести whitelist в отдельный сервис `src/services/whitelist-service.js`:
    - Отдельное хранилище (или таблица в SQLite)
    - Поддержка ролей (admin, user)
    - Валидация входных данных
  - [ ] Перестроить админ-панель как отдельный flow:
    - Независимое состояние
    - Авторизация через whitelist
    - Использование presentation-слоя для форматирования

- [ ] **Фаза 7: Финализация и документация** (см. [раздел 4](refactoring.md#4-роадмап-реализации))
  - [ ] **Регрессионное тестирование:**
    - [ ] Прогон всех smoke-тестов из фазы 0
    - [ ] Ручное тестирование критических сценариев:
      - Отправка одиночного ответа
      - Офлайн-очередь (сохранение + отправка после восстановления)
      - Burst detection и накопление кодов
      - Подтверждение при смене уровня
      - Работа inline-кнопок в Telegram и VK
      - Реавторизация при истечении cookies
    - [ ] Нагрузочное тестирование на production-подобных данных

  - [ ] **Документация:**
    - [ ] Обновить `docs/testing.md` с новыми тестовыми сценариями
    - [ ] Обновить `docs/platforms.md` с описанием presentation-слоя
    - [ ] Обновить `docs/deployment.md` с инструкциями по SQLite
    - [ ] Добавить `docs/database.md` с описанием схемы БД и миграций
    - [ ] Обновить README.md с новой архитектурой

  - [ ] **Версионирование и rollback:**
    - [ ] Создать git tags для каждой фазы (v2.0-phase1, v2.0-phase2, ...)
    - [ ] Документировать процедуры rollback для каждой фазы
    - [ ] Настроить автоматические бэкапы SQLite в production

  - [ ] **Мониторинг:**
    - [ ] Добавить логирование метрик (время ответа Encounter, размер очередей, количество ошибок)
    - [ ] Настроить алерты на критические события (долгие очереди, ошибки авторизации, рост БД)

## Технический долг (сложность и метрики)

Закладывал это как «параллельный» долг, но закрывать лучше после критичных фаз: сперва Фаза 3 (SQLite, без неё архитектура всё равно сыровата), затем Фаза 4 (Encounter API). Когда данные и транспорт будут чётко разделены, возвращаемся к техническому долгу — декомпозируем `router/encounter/user-store` и закрываем предупреждения линтера отдельным блоком.

- [ ] Снизить комплексность `src/features/router.js` (декомпозиция `handleCallback`, `processBatchSend`, presentation-слой)
- [ ] Декомпозировать `encounter-api.js` (повторяющиеся retry и обработка ошибок)
- [ ] Упростить `src/core/user-store.js` (загрузка/сохранение, распределить в репозитории/сервисы)
- [ ] Убрать дублирование клавиатур в `src/platforms/vk/vk-adapter.js` (unused vars, фабрика клавиатур)
